package br.com.azalim.stockmarket;

import br.com.azalim.stockmarket.asset.Asset;
import br.com.azalim.stockmarket.asset.MarketType;
import br.com.azalim.stockmarket.broker.Broker;
import br.com.azalim.stockmarket.company.Company;
import br.com.azalim.stockmarket.observer.Observable;
import br.com.azalim.stockmarket.observer.impl.TransactionObserver;
import br.com.azalim.stockmarket.operation.OperationBook;
import br.com.azalim.stockmarket.operation.offer.OfferOperation;
import br.com.azalim.stockmarket.wallet.Transaction;

import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Represents the stock market.
 */
public class StockMarket implements Observable<TransactionObserver> {

    /**
     * The singleton instance of this class.
     */
    private static StockMarket instance;

    /**
     * The operation books of the assets.
     */
    private Map<Asset, OperationBook> operationBooks = new HashMap<>();

    /**
     * The brokers of the stock market.
     */
    private Set<Broker> brokers = new HashSet<>();

    /**
     * The observers of the transactions.
     */
    private final Set<TransactionObserver> observers = new HashSet<>();

    /**
     * The executor service that runs the processing of the registered operations.
     * The thread generated by this executor is going to be named "Operation Processor".
     */
    private final ScheduledExecutorService operationProcessorExecutorService = Executors.newSingleThreadScheduledExecutor(runnable -> {
        Thread thread = new Thread(runnable);
        thread.setName("Operation Processor");
        return thread;
    });

    /**
     * Creates a new stock market.
     *
     * @param companies the companies of the stock market.
     * @param brokers   the brokers of the stock market.
     */
    public StockMarket(Collection<Company> companies, Collection<Broker> brokers) {

        Objects.requireNonNull(companies);
        Objects.requireNonNull(brokers);

        if (!Utils.isJUnitTest()) { // No singleton behaviour when unit testing

            if (instance != null) {
                throw new IllegalStateException("Stock market already instantiated");
            }

            instance = this;

        }

        companies.forEach(company -> company.getAssetTypes().stream()
                .mapMulti((assetType, consumer) -> {

                    Asset commonAsset = new Asset(company, assetType, MarketType.COMMON);
                    consumer.accept(commonAsset);

                    if (assetType.hasFractionalMarket()) {
                        consumer.accept(new Asset(commonAsset, MarketType.FRACTIONAL));
                    }

                })
                .map(Asset.class::cast)
                .forEach(stock -> this.operationBooks.put(stock, new OperationBook())));

        this.operationBooks = Collections.unmodifiableMap(this.operationBooks);

        this.brokers.addAll(brokers);
        this.brokers = Collections.unmodifiableSet(this.brokers);

    }

    /**
     * Retrieves the operation book of a given asset.
     *
     * @param asset the asset of the operation book.
     * @return the operation book of the given asset or null if it does not exist.
     * @throws IllegalArgumentException if the asset does not exist.
     */
    public OperationBook getOperationBook(Asset asset) {

        Objects.requireNonNull(asset);

        OperationBook operationBook = this.operationBooks.get(asset);

        if (operationBook == null) {
            throw new IllegalArgumentException("The asset does not exist: " + asset);
        }

        return operationBook;

    }

    /**
     * @return the unmodifiable map of all the operation books of the stock market.
     */
    public Map<Asset, OperationBook> getOperationBooks() {
        return this.operationBooks;
    }

    /**
     * @return the unmodifiable set of all the brokers of the stock market.
     */
    public Set<Broker> getBrokers() {
        return this.brokers;
    }

    /**
     * Starts processing the registered operations every one second.
     */
    public void startProcessingOperations() {

        this.getOperationBooks().values()
                .forEach(operationBook -> this.operationProcessorExecutorService.scheduleWithFixedDelay(
                        () -> operationBook.processOperations(this),
                        1, 1, TimeUnit.SECONDS
                ));

    }

    /**
     * Shutdowns the executor service that processes the registered operations.
     */
    public void stopProcessingOperations() {
        this.operationProcessorExecutorService.shutdown();
    }

    /**
     * Notifies the observers that a new transaction has been registered.
     *
     * @param from     the broker that sold the asset.
     * @param to       the broker that bought the asset.
     * @param asset    the asset that was bought and sold.
     * @param quantity the quantity of the asset that was bought and sold.
     * @param price    the price of the asset that was bought and sold.
     */
    public void notifyTransactionObservers(Broker from, Broker to, Asset asset, int quantity, double price) {
        this.observers.forEach(transactionObserver -> transactionObserver.onNewTransactionRegistered(from, to, asset, quantity, price));
    }

    /**
     * Subscribes to be notified of new transactions registered to the stock market.
     *
     * @param observer the observer that is going to be notified when new transactions are registered.
     */
    @Override
    public void observe(TransactionObserver observer) {
        Objects.requireNonNull(observer);
        this.observers.add(observer);
    }

    /**
     * @return the observers that are going to be notified when there is a new transaction registered.
     */
    @Override
    public Collection<TransactionObserver> getObservers() {
        return Collections.unmodifiableSet(this.observers);
    }

    /**
     * @return the singleton instance of stock market. Will always return null when unit testing.
     */
    public static StockMarket getInstance() {
        return instance;
    }

}
