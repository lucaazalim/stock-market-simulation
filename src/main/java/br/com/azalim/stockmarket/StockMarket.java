package br.com.azalim.stockmarket;

import br.com.azalim.stockmarket.asset.Asset;
import br.com.azalim.stockmarket.asset.MarketType;
import br.com.azalim.stockmarket.broker.Broker;
import br.com.azalim.stockmarket.broker.BrokerWallet;
import br.com.azalim.stockmarket.company.Company;
import br.com.azalim.stockmarket.observer.Observable;
import br.com.azalim.stockmarket.observer.impl.TransactionObserver;
import br.com.azalim.stockmarket.operation.OperationBook;
import br.com.azalim.stockmarket.operation.offer.OfferOperation;

import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Represents the stock market.
 */
public class StockMarket implements Observable<TransactionObserver> {

    /**
     * The singleton instance of this class.
     */
    private static StockMarket instance;

    /**
     * The operation books of the stocks.
     */
    private final Map<Asset, OperationBook> operationBooks = new HashMap<>();

    /**
     * The wallets of the brokers.
     */
    private final Map<Broker, BrokerWallet> wallets = new HashMap<>();

    /**
     * The observers of the transactions.
     */
    private final Set<TransactionObserver> observers = new HashSet<>();

    /**
     * The executor service that runs the processing of the registered operations.
     * The thread generated by this executor is going to be named "Operation Processor".
     */
    private final ScheduledExecutorService operationProcessorExecutorService = Executors.newSingleThreadScheduledExecutor(runnable -> {
        Thread thread = new Thread(runnable);
        thread.setName("Operation Processor");
        return thread;
    });

    /**
     * Creates a new stock market.
     *
     * @param companies the companies of the stock market.
     * @param brokers   the brokers of the stock market.
     */
    public StockMarket(Set<Company> companies, Set<Broker> brokers) {

        Objects.requireNonNull(companies);
        Objects.requireNonNull(brokers);

        if (!Utils.isJUnitTest()) { // No singleton behaviour when unit testing

            if (instance != null) {
                throw new IllegalStateException("Stock market already instantiated");
            }

            instance = this;

        }

        companies.forEach(company -> company.getAssetTypes().stream()
                .mapMulti((assetType, consumer) -> {

                    Asset commonAsset = new Asset(company, assetType, MarketType.COMMON);
                    consumer.accept(commonAsset);

                    if (assetType.hasFractionalMarket()) {
                        consumer.accept(new Asset(commonAsset, MarketType.FRACTIONAL));
                    }

                })
                .map(Asset.class::cast)
                .forEach(stock -> this.operationBooks.put(stock, new OperationBook())));

        brokers.forEach(broker -> this.wallets.put(broker, new BrokerWallet()));

    }

    /**
     * Retrieves the operation book of a given asset.
     *
     * @param asset the asset of the operation book.
     * @return the operation book of the given asset or null if it does not exist.
     * @throws IllegalArgumentException if the asset does not exist.
     */
    public OperationBook getOperationBook(Asset asset) {

        Objects.requireNonNull(asset);

        OperationBook operationBook = this.operationBooks.get(asset);

        if (operationBook == null) {
            throw new IllegalArgumentException("The asset does not exist: " + asset);
        }

        return operationBook;

    }

    /**
     * @return an unmodifiable collection of all the operation books of the stock market.
     */
    public Collection<OperationBook> getOperationBooks() {
        return Collections.unmodifiableCollection(this.operationBooks.values());
    }

    /**
     * @return an unmodifiable set of all the assets of the stock market.
     */
    public Set<Asset> getAssets() {
        return Collections.unmodifiableSet(this.operationBooks.keySet());
    }

    /**
     * @return an unmodifiable set of all the brokers of the stock market.
     */
    public Set<Broker> getBrokers() {
        return Collections.unmodifiableSet(this.wallets.keySet());
    }

    /**
     * Retrieves the wallet of a given broker.
     *
     * @param broker the owner of the wallet.
     * @return the wallet of the given broker or null if it does not exist.
     */
    public BrokerWallet getWallet(Broker broker) {

        Objects.requireNonNull(broker);

        BrokerWallet brokerWallet = this.wallets.get(broker);

        if (brokerWallet == null) {
            throw new IllegalArgumentException("The broker does not exist: " + broker);
        }

        return brokerWallet;

    }

    public void registerTransaction(OfferOperation sellOfferOperation, OfferOperation buyOfferOperation, int quantity) {

        Objects.requireNonNull(sellOfferOperation);
        Objects.requireNonNull(buyOfferOperation);

        Asset asset = sellOfferOperation.getAsset();

        if (!asset.equals(buyOfferOperation.getAsset())) {
            throw new IllegalArgumentException("The offer operations must be related to the same asset");
        }

        this.getOperationBook(asset); // Just to make sure the asset exists in this stock market

        if (quantity <= 0) {
            throw new IllegalArgumentException("The quantity must be greater than zero");
        }

        Broker from = sellOfferOperation.getBroker(), to = buyOfferOperation.getBroker();
        double price = sellOfferOperation.getPrice();

        this.getWallet(from).registerTransaction(asset, new Transaction(-quantity, price));
        this.getWallet(to).registerTransaction(asset, new Transaction(quantity, price));

        this.observers.forEach(transactionObserver -> transactionObserver.onNewTransactionRegistered(from, to, asset, quantity, price));

    }

    /**
     * Starts processing the registered operations every one second.
     */
    public void startProcessingOperations() {

        this.getOperationBooks().forEach(operationBook -> this.operationProcessorExecutorService.scheduleWithFixedDelay(
                () -> operationBook.processOperations(this),
                1, 1, TimeUnit.SECONDS
        ));

    }

    /**
     * Shutdowns the executor service that processes the registered operations.
     */
    public void stopProcessingOperations() {
        this.operationProcessorExecutorService.shutdown();
    }

    /**
     * Subscribes to be notified of new transactions registered to the stock market.
     *
     * @param observer the observer that is going to be notified when new transactions are registered.
     */
    @Override
    public void observe(TransactionObserver observer) {
        Objects.requireNonNull(observer);
        this.observers.add(observer);
    }

    /**
     * @return the observers that are going to be notified when there is a new transaction registered.
     */
    @Override
    public Collection<TransactionObserver> getObservers() {
        return Collections.unmodifiableSet(this.observers);
    }

    /**
     * @return the singleton instance of stock market. Will always return null when unit testing.
     */
    public static StockMarket getInstance() {
        return instance;
    }

}
